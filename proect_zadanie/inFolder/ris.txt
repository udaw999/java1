
Списочный массив ArrayList
Знакомство с ArrayList
Метод add()
Методы ensureCapacity() и trimToSize()
Метод indexOf()
Просмотр всех элементов через цикл
Метод contains()
Метод remove() - удаление элемента
Метод removeIf() - удаление элемента по предикату (Java 8)
Метод set() - замена элемента
Метод clear() - очистка массива
Метод toArray() - конвертируем в обычный массив
Сколько раз совпадают элементы
Интерфейс List
Структура данных в картинках
Объединяем два ArrayList
Сортировка
Интерфейс ListIterator
Знакомство с ArrayList
Усвоив, что такое массивы, можно поближе изучить java.util.ArrayList - самый популярный вид списков. По названию пространства имён видно, что данный класс относится к Java.

ArrayList - автоматически расширяемый массив. Вы можете работать с массивом, но при этом не используются квадратные скобки.

Массивы имеют фиксированную длину, и после того как массив создан, он не может расти или уменьшаться. ArrayList может менять свой размер во время исполнения программы, при этом не обязательно указывать размерность при создании объекта. Кроме того, вы без проблем можете вставить новый элемент в середину коллекции. А также спокойно удалить элемент из любого места. Элементы ArrayList могут быть абсолютно любых типов в том числе и null. Это удобно, когда вы не знаете точного размера массива. Для сравнения - гостиница для котов имеет фиксированное число номеров, массив использовать можно. Вы владелец преуспевающей компании и число наёмных работников постоянно увеличивается, обычный массив создавать для учёта сотрудников нецелесообразно. В этом случае удобнее работать со списочным массивом. Иногда говорят, что ArrayList - это массив на стероидах (продвинутый).

Работать с ArrayList просто: создайте нужный объект, вставьте объект методом add(), обращайтесь к нему методом get(), используйте индексирование так же, как для массивов, но без квадратных скобок. ArrayList также содержит метод size(), который возвращает текущее количество элементов в массиве (напомню, что в обычном массиве используется свойство length).

Переменные принято называть во множественном числе.

Рассмотрим на примерах.


ArrayList catNames = new ArrayList();
catNames.add("Васька");
mResultEditText.setText(catnamesList.get(0));
Запускаем программу и видим, что в текстовом поле отобразилось имя кота Васьки. Что же произошло? Мы объявили экземпляр класса ArrayList под именем catNames и через метод add() добавили имя. Списочный массив стал содержать одну строку и мы можем в этом убедиться, когда выводим в текстовом поле первый элемент массива через индекс, равный 0.

Продолжим опыт. Перенесём объявление класса на уровень нашего основного класса и добавим через кнопку ещё два имени.


private ArrayList mCatNames = new ArrayList();

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    mButton = (Button) findViewById(R.id.buttonGetResult);
    mResultEditText = (EditText) findViewById(R.id.editText);
    mInfoTextView = (TextView) findViewById(R.id.textViewInfo);

    mCatNames.add("Васька");
    mResultEditText.setText(mCatNames.get(0));
}

public void onClick(View view) {

    mCatNames.add("Мурзик");
    mCatNames.add("Рыжик");
    mInfoTextView.setText((CharSequence) mCatNames.get(1));
}
Что теперь произошло? В методе onCreate() как прежде добавляется одно имя, которое выводится в текстовом поле. При нажатии на кнопку мы добавляем ещё два имени, а в текстовой метке выводим имя второго кота через метод catnamesList.get(1).

Хорошо, мы знаем, что добавили трёх котов и поэтому можем обращаться через индекс 0, 1 или 2. А если котов стало слишком много, и мы запутались в их количестве? Тогда нужно вызвать метод size(), который вернёт общее число элементов массива. В этом случае, чтобы получить имя последнего кота в массиве, нужно получить размер массива и отнять единицу.


mInfoTextView.setText(mCatNames.get(mCatNames.size() - 1));
Вроде бы всё замечательно. Но студия выводит предупреждение у кода метода add(). Почему?

Мы знаем, что у кота есть четыре лапы и хвост. Создадим отдельную переменную для количества лап и попробуем запихнуть их в массив имён. Выглядит как бред, но Java не ругается на наши действия. Вы можете через метод size() убедиться, что размер массива увеличился. Но при попытке вывести последний элемент получим ошибку.


public void onClick(View view) {

    mCatNames.add("Мурзик");
    mCatNames.add("Рыжик");

    int paws = 4; // четыре лапы
    mCatNames.add(paws);

    mInfoTextView.setText(mCatNames.get(mCatNames.size() - 1));
}
Чтобы вы не совершали подобных ошибок, был придуман следующий подход. Когда вы создаёте новый объект для массива, то в угловых скобках сразу указываете, какой тип собираетесь использовать.


ArrayList<String> mCatNames = new ArrayList<>();
Как только вы исправите пример, то строчка mCatNames.add(paws); будет сразу подчёркнута красной линией. Java поняла, что мы хотим использовать в массиве только строки, а не числа. Поэтому, вы уже не совершите глупых ошибок. Удалите неправильную строку, остальное можно оставить без изменений.


private ArrayList<String> mCatNames = new ArrayList<String>();

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    mButton = findViewById(R.id.buttonGetResult);
    mResultEditText = findViewById(R.id.editText);
    mInfoTextView = findViewById(R.id.textViewInfo);

    mCatNames.add("Васька");
    mResultEditText.setText(mCatNames.get(0));
}

public void onClick(View view) {

    mCatNames.add("Мурзик");
    mCatNames.add("Рыжик");
    // добавим ещё одного наглого кота. Он очень настаивал
    mCatNames.add("Барсик");
    // выводим имя последнего кота из массива и размер массива
    mInfoTextView.setText(mCatNames.get(mCatNames.size() - 1) + 
            " Размер массива " + mCatNames.size());
}
Теперь студия не ругается, и мы можем свернуться калачиком и поспать.

Проснулись? Продолжим.

Такая форма записи с угловыми скобками говорит о том, что мы использовали generic-класс (дженерик или обобщение) с типизированными параметрами.

В Java 7 появилась укороченная запись, называемая ромбовидной. Вы можете опустить параметр с правой стороны выражения.


ArrayList<String> mCatNames = new ArrayList<>();
В обобщениях можно использовать только объекты классов. Поэтому запись ArrayList<int> не прокатит. В таких случаях следует использовать класс Integer: ArrayList<Integer>. Но с другой стороны это чревато большим расходом памяти.

Если у вас есть собственный класс, то он используется таким же образом, только с использованием ключевого слова new.


ArrayList<Cat> cats = new ArrayList<>();
cats.add(new Cat("Васька"));
cats.add(new Cat("Барсик"));
Метод add()
Метод add() самый популярный и не требует особых объяснений. Только не забывайте, что существует перегруженная версия метода, позволяющая вставлять элемент в нужную позицию.


cats.add(2, new Cat("Рыжик"));
Следует быть осторожным, чтобы ненароком не вставить в несуществующую позицию. По возможности, избегайте операций вставки в середину коллекции. Ведь системе приходится заново пересчитывать индексы элементов.

Методы ensureCapacity() и trimToSize()
Если заранее известно, сколько элементов следует хранить, то перед заполнением массива вызовите метод ensureCapacity():


mCatNames.ensureCapacity(100);
Первоначальную ёмкость можно задать и в конструкторе в качестве параметра.


ArrayList<String> mCatNames = new ArrayList<>(100);
Если вы уверены, что списочный массив будет иметь постоянный размер, то можете использовать метод trimToSize(). Это может способствовать рациональному использованию памяти.

Метод indexOf()
Предположим, мы внимательно следим за Рыжиком. Когда он был последним, то его легко было вычислить. Зная размер массива, мы вычитали единицу и получали к нему доступ. Но потом мы стали добавлять в массив других котов и уже не сможем понять, где теперь наш Рыжик. Но выход всегда есть. Существует метод indexOf(), который ищет подходящий элемент и выводит его индекс.


int index = mCatNames.indexOf("Рыжик");

// выводим имя кота и его номер в массиве
mInfoTextView.setText("Рыжик числится под номером " + index);
Не забываем, что отсчёт массива идёт с 0, если индекс равен 2, значит он является третим в массиве.

Просмотр всех элементов через цикл
Чтобы вывести всех усатых-полосатых на чистую воду, используем цикл for:


String catName = "";
for (int i = 0; i < mCatNames.size(); i++) {
    catName = catName + mCatNames.get(i) + " ";
}

mInfoTextView.setText("Все коты: " + catName);
Или укороченная запись:


String catName = "";
for (String name : mCatNames) {
    catName = catName + name + " ";
}

mInfoTextView.setText("Все коты: " + catName);
Метод contains()
Чтобы узнать, есть в массиве какой-либо элемент, можно воспользоваться методом contains(), который вернёт true или false:


mInfoTextView.setText(mCatNames.contains("Бобик") + "");
Понятно, что в нашем массиве никаких бобиков и барбосов быть не может, поэтому появится надпись false.

Метод remove() - удаление элемента
Для удаления элемента из массива используется метод remove(). Можно удалять по индексу или по объекту:


mCatNames.remove(0); // удаляем по индексу
mCatNames.remove("Васька"); // удаляем по объекту
Элементы, следующие после удалённого элемента, сдвигаются влево, а размер списочного массива уменьшается на единицу.

Метод removeAll() удаляет сразу все элементы. Но лучше использовать метод clear().

Метод removeIf() - удаление элемента по предикату (Java 8)
Раньше, если нужно было удалить элемент из списка по условию, приходилось проходить в цикле по всем элементам и сравнивать их с условием. В Java 8 появился новый метод removeIf(), позволяющий упростить код. Метод использует предикат - вы указываете условие, если оно выполняется, то происходит удаление элемента из списка.


ArrayList<Integer> numList = new ArrayList<>();

numList.add(51);
numList.add(14);
numList.add(11);
numList.add(12);
numList.add(31);
numList.add(21);

System.out.println("Оригинал: " + numList.toString());
// удаляем элементы, которые больше 10 и меньше 20
numList.removeIf(i -> (i > 10 && i < 20));

System.out.println("Новый список: " + numList.toString());

// Оригинал: [51, 14, 11, 12, 31, 21]
// Новый список: [51, 31, 21]
Метод set() - замена элемента
Чтобы заменить элемент в массиве, нужно использовать метод set() с указанием индекса и новым значением. Предположим, вы обнаружили, что у вас не кот Мурзик, а кошка Мурка. Нет проблем.


mCatNames.add("Васька");
mCatNames.add("Мурзик");
mCatNames.add("Рыжик");

mCatNames.set(1, "Мурка");

mInfoTextView.setText(mCatNames.get(1) + "");
Метод clear() - очистка массива
Для очистки массива используется метод clear():


mCatNames.clear();
Метод работает гораздо быстрее похожего метода removeAll().

Метод toArray() - конвертируем в обычный массив
Также можно сконвертировать из нашего списка в обычный массив и выполнить другие операции. Читайте документацию.


ArrayList<String> days = new ArrayList<>();

days.add("Monday");
days.add("Tuesday");
days.add("Wednesday");
days.add("Thursday");
days.add("Friday");
days.add("Saturday");
days.add("Sunday");

String[] daysArray = days.toArray(new String[days.size()]);

System.out.println("Массив: " + Arrays.toString(daysArray));
Конвертация в массив может понадобится для ускорения некоторых операций, передачи массива в качестве параметра методам, которые требуют именно массив и другие причины.

Можно было реализовать эту задачу самостоятельно - создать пустой массив, в цикле пройтись по элементам ArrayList и поместить каждый элемент в массив. Важно только проследить за размером массива, который должен совпасть с размером списка.


ArrayList<String> days = new ArrayList<>();

days.add("Monday");
days.add("Tuesday");
days.add("Wednesday");
days.add("Thursday");
days.add("Friday");
days.add("Saturday");
days.add("Sunday");

String[] daysArray = new String[days.size()];

for (int i = 0; i < days.size(); i++) {
    daysArray[i] = days.get(i);
}

System.out.println("Массив: " + Arrays.toString(daysArray));
В Java 8 появился ещё один вариант через Stream.


ArrayList<String> days = new ArrayList<>();

days.add("Monday");
days.add("Tuesday");
days.add("Wednesday");
days.add("Thursday");
days.add("Friday");
days.add("Saturday");
days.add("Sunday");

String[] daysArray = days.stream().toArray(String[]::new);

System.out.println("Массив: " + Arrays.toString(daysArray));
Сколько раз совпадают элементы
В списочном массиве значения вполне могут совпадать. Например, среди котов попадаются однофамильцы и мы их спокойно можем запихнуть в ArrayList. Но сколько раз повторяются одинаковые элементы?


ArrayList<String> cats = new ArrayList<>();
cats.add("Мурзик");
cats.add("Васька");
cats.add("Мурзик");

int count = Collections.frequency(cats, "Мурзик"); // получим результат 2
mInfoTextView.setText(String.valueOf(count)); // выводим результат в TextView
Интерфейс List
java.util.List является интерфейсом и его можно использовать вместо ArrayList следующим образом:


List<String> catnamesList = new ArrayList<String>();
Или укороченный вариант для Java 7:


List<String> catnamesList = new ArrayList<>();
Как видите, мы заменили ArrayList на List, но при этом в объявлении оставили new ArrayList(). Всё остальное остаётся без изменений. Кстати, этот способ является рекомендуемым. Но иногда он может не подойти.

Контейнеры List гарантируют определённый порядок следования элементов. Интерфейс List дополняет Collection несколькими методами, обеспечивающими вставку и удаление элементов в середине списка.

Существует две основные разновидности List:

Базовый контейнер ArrayList, оптимизированный для произвольного доступа к элементам, но с относительно медленными операциями вставки/удаления элементов в середине списка.
Контейнер LinkedList, оптимизированный для последовательного доступа, с быстрыми операциями вставки/удаления в середине списка. Произвольный доступ к элементам LinkedList выполняется относительно медленно, но по широте возможностей превосходит ArrayList.
В отличие от массива контейнер List позволяет добавлять и удалять элементы после создания, а также изменяет свои размеры.

Метод contains() проверяет, присутствует ли объект в списке. Чтобы удалить объект, передайте ссылку на него методу remove(). Кроме того, если у вас имеется ссылка на объект, вы можете определить индекс объекта в List при помощи метода indexOf().

Сам List реализует более общий интерфейс коллекции Collection и можно было даже написать:


Collection<String> mCatNames = new ArrayList<String>();
Но у Collection нет методов set() и get(), поэтому работать с таким интерфейсом не очень удобно.

Для создания массива можно не только добавлять по одному объекту через метод add(), но и сразу массив через метод Arrays.asList().

Оставим пока в покое котов и создадим массив из объектов Integer.


List<Integer> numbers = Arrays.asList(1, 2, 5, 9, 11);

mInfoTextView.setText(numbers.get(2) + ""); // выводит число 5
Но у данного способа есть недостаток. Если вы определили массив таким образом, то уже не можете вставлять или удалять другой элемент (методы add() и delete()), хотя при этом можете изменять существующий элемент.

check